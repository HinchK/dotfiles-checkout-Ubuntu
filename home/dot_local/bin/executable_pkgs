#!/usr/bin/env bash

set -euo pipefail

usage() {
  echo "Usage: ${0} install|uninstall|installed|installed-programs <pkgs>..." >&2
  exit "${1}"
}

positional_args=()
while [[ $# -gt 0 ]]; do
  case $1 in
  -*)
    echo "Error: unknown option ${1}." >&2
    usage 1
    ;;
  *)
    positional_args+=("$1")
    shift
    ;;
  esac
done

set -- "${positional_args[@]}"
unset positional_args

if [[ $# -lt 1 ]]; then
  usage 1
fi

action="$1"
shift

bin_dir="/usr/local/bin"
uid=$(id -u)
if [[ "${uid}" -ne 0 ]]; then
  bin_dir="${HOME}/.local/bin"
fi
unset uid
mkdir -p "${bin_dir}"

pantry_synced=false
function sync_pantry_once() {
  if [[ "${pantry_synced}" == false ]]; then
    pkgx --sync --quiet
    pantry_synced=true
  fi
}

function resolve_pkg_spec() {
  local pkg="${1}"
  local pkg_suffix=""
  if [[ "${pkg}" =~ ^[^@^~]+([@^~].+)?$ ]]; then
    pkg_suffix="${BASH_REMATCH[1]:-}"
  fi
  sync_pantry_once
  pkgx --query --json=v2 "${pkg}" | jq -er '.[0].project' | sed "s/$/${pkg_suffix}/"
}

function is_shim() {
  local shim="${1}"
  shift
  local projects=("${@}")
  grep -I -q . "${shim}" || return 1 # binary
  if [[ ${#projects[@]} -gt 0 ]]; then
    local project
    local escaped_project
    for project in "${projects[@]}"; do
      # https://stackoverflow.com/a/29613573/12156188
      escaped_project=$(sed 's/[^^]/[&]/g; s/\^/\\^/g' <<<"${project}")
      head -n 1 "${shim}" | grep "^#!/usr/bin/env -S pkgx --shebang " | grep -q -E " \+${escaped_project//"."/"\."}" && return 0
      grep -q -E "exec pkgx \+${escaped_project//"."/"\."}" "${shim}" && return 0 # pkgx v1
    done
  else
    head -n 1 "${shim}" | grep -q "^#!/usr/bin/env -S pkgx --shebang " && return 0
    grep -q -E "exec pkgx \+[^ ]+" "${shim}" && return 0 # pkgx v1
  fi
  return 1
}

function get_shim_pkg_spec() {
  local shim="${bin_dir}/${1}"
  head -n 1 "${shim}" | grep "^#!/usr/bin/env -S pkgx --shebang " | grep -o -P ' \+\K[^ ]+' && return 0
  grep -o -m1 -P "exec pkgx \+\K[^ ]+" "${shim}" && return 0 # pkgx v1
  return 1
}

function programs_installed() {
  if [[ ! -d "${bin_dir}" ]]; then
    return
  fi
  local pkg_specs=()
  if [[ $# -gt 0 ]]; then
    local pkg
    for pkg in "$@"; do
      pkg_specs+=("$(resolve_pkg_spec "${pkg}")")
    done
  fi

  local bins
  bins="$(find "${bin_dir}" -mindepth 1 -maxdepth 1 -type f -executable)"
  if [[ -z "${bins}" ]]; then
    return
  fi
  readarray -t bins <<<"${bins}"

  local bin
  local programs=()
  for bin in "${bins[@]}"; do
    if
      # shellcheck disable=SC2310
      is_shim "${bin}" "${pkg_specs[@]}"
    then
      programs+=("$(basename "${bin}")")
    fi
  done

  printf '%s\n' "${programs[@]}" | sort -u
}

function pkgs_installed() {
  local programs
  programs=$(programs_installed "${@}")
  if [[ -z "${programs}" ]]; then
    return
  fi
  readarray -t programs <<<"${programs}"

  local program
  local pkg_specs=()
  for program in "${programs[@]}"; do
    pkg_specs+=("$(get_shim_pkg_spec "${program}")")
  done

  printf '%s\n' "${pkg_specs[@]}" | sort -u
}

function uninstall() {
  local pkg_specs=()
  if [[ $# -gt 0 ]]; then
    local pkg
    for pkg in "$@"; do
      pkg_specs+=("$(resolve_pkg_spec "${pkg}")")
    done
  fi

  local pkg_specs
  pkg_specs=$(pkgs_installed "${pkg_specs[@]}")
  if [[ -z "${pkg_specs}" ]]; then
    return
  fi
  readarray -t pkg_specs <<<"${pkg_specs}"

  local pkg_spec
  for pkg_spec in "${pkg_specs[@]}"; do
    local programs
    programs=$(programs_installed "${pkg_spec}" | grep .)
    if [[ -z "${programs}" ]]; then
      continue
    fi
    readarray -t programs <<<"${programs}"

    echo "uninstalling ${pkg_spec} (${programs[*]})"
    local program
    for program in "${programs[@]}"; do
      rm -f "${bin_dir}/${program}"
    done
  done
}

case "${action}" in
install)
  if [[ $# -eq 0 ]]; then
    # reinstall all installed packages
    pkgs_text=$(pkgs_installed | grep .)
    readarray -t pkgs <<<"${pkgs_text}"
    unset pkgs_text
  else
    pkgs=("$@")
  fi
  sync_pantry_once
  for pkg in "${pkgs[@]}"; do
    if [[ "${pkg}" =~ ^[^@^~]+([@^~].+)?$ ]]; then
      pkg_suffix="${BASH_REMATCH[1]:-}"
    else
      pkg_suffix=""
    fi
    pkg_json=$(pkgx --query --json=v2 "${pkg}" | jq -e '.[0]')
    project=$(echo "${pkg_json}" | jq -er '.project')

    # uninstall if some version is already installed
    uninstall "${project}"

    pkg_spec="${project}${pkg_suffix}"
    programs_text=$(echo "${pkg_json}" | jq -er '.programs[]')
    readarray -t programs <<<"${programs_text}"
    unset programs_text

    for program in "${programs[@]}"; do
      bin="${bin_dir}/${program}"
      if [[ -e "${bin}" ]]; then
        echo "Error: ${bin} already exists and is not a pkgx shim." >&2
        exit 1
      fi
    done

    echo "installing ${pkg_spec} (${programs[*]})"
    for program in "${programs[@]}"; do
      bin="${bin_dir}/${program}"
      bin_tmp=$(mktemp "${bin}.tmp.XXXXXX")
      tee "${bin_tmp}" >/dev/null <<EOF
#!/usr/bin/env -S pkgx --shebang --quiet +${pkg_spec} -- ${program}
EOF
      mkdir -p "$(dirname "${bin}")"
      install "${bin_tmp}" "${bin}"
      rm -f "${bin_tmp}"
    done
  done

  if [[ ":${PATH}:" != *":${bin_dir}:"* ]]; then
    echo "Warning: ${bin_dir} is not in the PATH. You may need to add it manually." >&2
  fi

  ;;
uninstall)
  uninstall "${@}"
  ;;
installed-programs)
  programs_installed "${@}" | grep .
  ;;
installed)
  pkgs_installed "${@}" | grep .
  ;;
*)
  echo "Error: unknown action ${action}." >&2
  usage 1
  ;;
esac
